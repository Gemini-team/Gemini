#pragma require 2darray
#pragma require setrtarrayindexfromanyshader
#pragma require uav

#include "UnityCG.cginc"
#include "UnityShaderVariables.cginc"

UNITY_DECLARE_TEX2DARRAY(depthImages);

float4x4 CameraRotationMatrices[31];
float4x4 inv_CameraMatrix;
float4x4 CameraMatrix;

uint ImageWidthRes;
uint ImageHeightRes;
int NrOfImages;

// https://stackoverflow.com/questions/32227283/getting-world-position-from-depth-buffer-value
float3 ImageToCartesian(float depthData, uint2 TexCoord, uint cam_index) {

	//float depth = depthImage[TexCoord.xy].x;
	float depth = depthData;
	float W = float(ImageWidthRes);
	float H = float(ImageHeightRes);


	// from Unity image frame to OpenGL clip space
	float x = 2 * TexCoord.x / W - 1;
	float y = 2 * TexCoord.y / H - 1;
	float z = (1 - depth) * 2.0 - 1.0;

	// if depth == 0  (i.e. at far plane) -> set z to 0
	if ((1 - depth) == 1) {
		z = -1; // HACK what purpose does it serve to set z to zero? 
	}

	float4 clipSpacePosition = float4(x, y, z, 1.0);
	float4 viewSpacePosition = mul(inv_CameraMatrix, clipSpacePosition); // inverted projection matrix (as provided by openGL, right handed)
	// see bottom of first answer of https://answers.unity.com/questions/1359718/what-do-the-values-in-the-matrix4x4-for-cameraproj.html

	// Perspective division
	viewSpacePosition /= viewSpacePosition.w;
	viewSpacePosition.z *= -1; // convert from right handed [right, up, backward] to left handed [right, up, forward]

	float4 bodySpacePosition = mul(CameraRotationMatrices[cam_index], viewSpacePosition); // rotation matrix provided by Unity (in left handed land) 

	return bodySpacePosition.xyz;
}

float3 ImagesToCartesian(uint2 TexCoord) {

	uint n_camera = TexCoord.x / ImageWidthRes;
	TexCoord.x = TexCoord.x % ImageWidthRes;

	float3 UVWCoord = float3(TexCoord.x/float(ImageWidthRes), TexCoord.y/float(ImageHeightRes), n_camera); //index by UVZ

	float depthData = UNITY_SAMPLE_TEX2DARRAY_LOD(depthImages, UVWCoord, 0).x;

	return ImageToCartesian(depthData, TexCoord, n_camera);

}
